/** * $Id: DefaultJFinalConfig.java,v 1.0 2019-08-08 21:57 chenmin Exp $ */package com.github.jfinal.config;import com.jfinal.aop.Interceptor;import com.jfinal.captcha.ICaptchaCache;import com.jfinal.config.*;import com.jfinal.core.ActionHandler;import com.jfinal.core.ControllerFactory;import com.jfinal.handler.Handler;import com.jfinal.json.IJsonFactory;import com.jfinal.log.ILogFactory;import com.jfinal.plugin.IPlugin;import com.jfinal.plugin.activerecord.ActiveRecordPlugin;import com.jfinal.proxy.ProxyFactory;import com.jfinal.render.IRenderFactory;import com.jfinal.template.Engine;import com.jfinal.template.source.StringSource;import com.jfinal.token.ITokenCache;import lombok.Data;import lombok.experimental.Accessors;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;import org.springframework.core.io.Resource;import org.springframework.core.io.support.PathMatchingResourcePatternResolver;import org.springframework.core.io.support.ResourcePatternResolver;import org.springframework.stereotype.Component;import org.springframework.util.ObjectUtils;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.util.ArrayList;import java.util.Arrays;import java.util.List;import java.util.Map;/** * @author 陈敏 * @version $Id: DefaultJFinalConfig.java,v 1.1 2019-08-08 21:57 chenmin Exp $ * Created on 2019-08-08 21:57 * My blog： https://www.chenmin.info */@Component@Slf4j@Data@Accessors(chain = true)public class DefaultJFinalConfig extends JFinalConfig implements ApplicationContextAware {    @Autowired    private JfinalProperties jfinalProperties;    @Autowired    private IJsonFactory jsonFactory;    @Autowired    private IRenderFactory renderFactory;    @Autowired    private ICaptchaCache captchaCache;    @Autowired    private ILogFactory logFactory;    @Autowired    private ProxyFactory proxyFactory;    @Autowired    private ControllerFactory controllerFactory;    @Autowired    private ITokenCache tokenCache;    @Autowired    private ActionHandler actionHandler;    private ApplicationContext applicationContext;    @Override    public void configConstant(Constants me) {        me.setDevMode(jfinalProperties.getDevMode());        me.setInjectDependency(jfinalProperties.getInjectDependency());        me.setBaseUploadPath(jfinalProperties.getBaseUploadPath());        me.setBaseDownloadPath(jfinalProperties.getBaseDownloadPath());        me.setConfigPluginOrder(0);        me.setEncoding("UTF-8");        Map<Integer, String> errorViewMapping = jfinalProperties.getErrorViewMapping();        if (!ObjectUtils.isEmpty(errorViewMapping)) {            errorViewMapping.forEach((errorCode, errorView) -> me.setErrorView(errorCode, errorView));        }        me.setFreeMarkerTemplateUpdateDelay(jfinalProperties.getDelayInSeconds());        me.setI18nDefaultBaseName(jfinalProperties.getDefaultBaseName());        me.setI18nDefaultLocale(jfinalProperties.getDefaultLocale());        me.setInjectDependency(jfinalProperties.getInjectDependency());        me.setInjectSuperClass(jfinalProperties.getInjectSuperClass());        me.setReportAfterInvocation(jfinalProperties.getReportAfterInvocation());        me.setJsonDatePattern(jfinalProperties.getDatePattern());        me.setUrlParaSeparator(jfinalProperties.getUrlParaSeparator());        me.setViewExtension(jfinalProperties.getViewExtension());        me.setViewType(jfinalProperties.getViewType());        me.setMaxPostSize(jfinalProperties.getMaxPostSize());        me.setJsonFactory(jsonFactory);        me.setRenderFactory(renderFactory);        me.setCaptchaCache(captchaCache);        me.setLogFactory(logFactory);        me.setProxyFactory(proxyFactory);        me.setControllerFactory(controllerFactory);        me.setTokenCache(tokenCache);    }    @Override    public void configRoute(Routes me) {        Map<String, Routes> routesMap = applicationContext.getBeansOfType(Routes.class);        if (!ObjectUtils.isEmpty(routesMap)) {            routesMap.values().forEach(routes -> me.add(routes));        }        Map<String, Interceptor> interceptorMap = applicationContext.getBeansOfType(Interceptor.class);        if (!ObjectUtils.isEmpty(interceptorMap)) {            interceptorMap.values().forEach(interceptor -> me.addInterceptor(interceptor));        }        me.setBaseViewPath(jfinalProperties.getBaseViewPath());        me.setClearAfterMapping(jfinalProperties.getClearAfterMapping());        me.setMappingSuperClass(jfinalProperties.getMappingSuperClass());    }    @Override    public void configEngine(Engine me) {        log.info("DefaultJFinalConfig.configEngine");    }    @Override    public void configPlugin(Plugins me) {        Map<String, IPlugin> pluginMap = applicationContext.getBeansOfType(IPlugin.class);        if (!ObjectUtils.isEmpty(pluginMap)) {            pluginMap.values().forEach(plugin -> {                me.add(plugin);            });        }    }    @Override    public void configInterceptor(Interceptors me) {        Map<String, Interceptor> interceptorMap = applicationContext.getBeansOfType(Interceptor.class);        if (!ObjectUtils.isEmpty(interceptorMap)) {            interceptorMap.values().forEach(interceptor -> me.add(interceptor));        }    }    @Override    public void configHandler(Handlers me) {        Map<String, Handler> handlerMap = applicationContext.getBeansOfType(Handler.class);        if (!ObjectUtils.isEmpty(handlerMap)) {            handlerMap.values().forEach(handler -> me.add(handler));        }        me.setActionHandler(actionHandler);    }    private void getSqlTemplates(ActiveRecordPlugin arp) {        ResourcePatternResolver resourceResolver = new PathMatchingResourcePatternResolver();        List<Resource> resources = new ArrayList<Resource>();        String template = this.jfinalProperties.getTemplate();        if (template != null) {            try {                Resource[] sqlTemplates = resourceResolver.getResources(template);                resources.addAll(Arrays.asList(sqlTemplates));            } catch (IOException e) {                // ignore            }        }        resources.forEach(resource -> {            StringBuilder content = null;            try {                content = getContentByStream(resource.getInputStream());                arp.addSqlTemplate(new StringSource(content, true));            } catch (IOException e) {                e.printStackTrace();            }        });    }    private StringBuilder getContentByStream(InputStream inputStream) {        StringBuilder stringBuilder = new StringBuilder();        try {            BufferedReader br = new BufferedReader(new InputStreamReader(inputStream, "UTF-8"));            String line;            while ((line = br.readLine()) != null) {                stringBuilder.append(line);            }        } catch (Exception e) {            e.printStackTrace();        }        return stringBuilder;    }}